<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üìù Exercise Generator - Study Lenses</title>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0f0f23;
            color: #ccc;
            min-height: 100vh;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header h1 { color: white; font-size: 24px; }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-primary { background: #48bb78; color: white; }
        .btn-primary:hover { background: #38a169; transform: translateY(-2px); }
        .btn-secondary { background: #4a5568; color: white; }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr 1.2fr;
            gap: 20px;
            padding: 20px;
            height: calc(100vh - 80px);
        }
        
        .panel {
            background: #1a1a2e;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .panel-header {
            background: #16213e;
            padding: 15px 20px;
            font-weight: 600;
            border-bottom: 1px solid #333;
        }
        
        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }
        
        .code-editor {
            width: 100%;
            height: 100%;
            background: #0d1117;
            color: #c9d1d9;
            border: none;
            padding: 15px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: none;
        }
        
        .trace-item {
            background: #16213e;
            margin: 6px 0;
            padding: 10px 12px;
            border-radius: 6px;
            border-left: 3px solid #667eea;
            font-family: monospace;
            font-size: 13px;
        }
        
        .trace-call { border-left-color: #48bb78; }
        .trace-return { border-left-color: #f6ad55; }
        
        .quiz-card {
            background: #16213e;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
            border: 2px solid transparent;
            transition: all 0.3s;
        }
        
        .quiz-card.correct { border-color: #48bb78; background: rgba(72, 187, 120, 0.1); }
        .quiz-card.incorrect { border-color: #f56565; background: rgba(245, 101, 101, 0.1); }
        
        .quiz-type {
            font-size: 11px;
            text-transform: uppercase;
            color: #667eea;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        .quiz-question {
            font-size: 16px;
            margin-bottom: 15px;
            color: #fff;
        }
        
        .quiz-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .quiz-option {
            padding: 12px 16px;
            background: #0d1117;
            border: 2px solid #333;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .quiz-option:hover { border-color: #667eea; background: #1a1a2e; }
        .quiz-option.selected { border-color: #667eea; background: rgba(102, 126, 234, 0.2); }
        .quiz-option.correct-answer { border-color: #48bb78; background: rgba(72, 187, 120, 0.2); }
        .quiz-option.wrong-answer { border-color: #f56565; background: rgba(245, 101, 101, 0.2); }
        
        .quiz-input {
            width: 100%;
            padding: 12px 16px;
            background: #0d1117;
            border: 2px solid #333;
            border-radius: 8px;
            color: #fff;
            font-size: 16px;
        }
        
        .quiz-input:focus { outline: none; border-color: #667eea; }
        
        .quiz-feedback {
            margin-top: 12px;
            padding: 10px;
            border-radius: 6px;
            font-weight: 600;
        }
        
        .feedback-correct { background: rgba(72, 187, 120, 0.2); color: #48bb78; }
        .feedback-incorrect { background: rgba(245, 101, 101, 0.2); color: #f56565; }
        
        .sortable-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .sortable-item {
            padding: 12px 16px;
            background: #0d1117;
            border: 2px solid #333;
            border-radius: 8px;
            cursor: grab;
            user-select: none;
            font-family: monospace;
        }
        
        .sortable-item:active { cursor: grabbing; }
        .sortable-item.dragging { opacity: 0.5; border-color: #667eea; }
        
        .check-btn {
            margin-top: 12px;
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }
        
        .check-btn:hover { background: #5a67d8; }
        
        .lang-tab {
            padding: 8px 16px;
            background: #2d2d30;
            color: #858585;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
        }
        .lang-tab.active {
            background: #667eea;
            color: white;
        }
        .editor-panel { display: none; }
        .editor-panel.active { display: block; height: 100%; }
        
        .stats-bar {
            display: flex;
            gap: 20px;
            padding: 10px 20px;
            background: #16213e;
            font-size: 13px;
        }
        
        .stat { display: flex; gap: 6px; }
        .stat-value { color: #667eea; font-weight: 700; }
        
        .empty-state {
            text-align: center;
            padding: 40px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üìù Exercise Generator</h1>
        <div style="display: flex; gap: 10px; align-items: center;">
            <button class="lang-tab active" onclick="switchLang('js')">‚ö° JS</button>
            <button class="lang-tab" onclick="switchLang('python')">üêç Python</button>
            <button class="btn btn-primary" onclick="runAndGenerate()">‚ñ∂Ô∏è Template Quizzes</button>
            <button class="btn btn-primary" onclick="runWithLLM()" style="background: #9f7aea;">ü§ñ AI Quizzes</button>
            <a href="index.html" class="btn btn-secondary">‚Üê Back</a>
        </div>
    </div>
    
    <div class="container">
        <div class="panel">
            <div class="panel-header">üìù Code Editor</div>
            <div class="panel-content" style="padding: 0;">
                <div class="editor-panel active" id="jsEditor">
                    <textarea class="code-editor" id="jsCode">// Write your JavaScript code here - auto-traced!
function greet(name) {
    return "Hello, " + name + "!";
}

function multiply(a, b) {
    return a * b;
}

function calculate(x, y) {
    const greeting = greet("Tracer");
    const result = multiply(x, y);
    return greeting + " Result: " + result;
}

// Test the functions
console.log(calculate(4, 5));</textarea>
                </div>
                <div class="editor-panel" id="pythonEditor">
                    <textarea class="code-editor" id="pythonCode">def greet(name):
    return f"Hello, {name}!"

def multiply(a, b):
    return a * b

def calculate(x, y):
    greeting = greet("Tracer")
    result = multiply(x, y)
    return f"{greeting} Result: {result}"

# Test the functions
print(calculate(4, 5))</textarea>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <div class="panel-header">üîç Execution Trace</div>
            <div class="stats-bar">
                <div class="stat">Calls: <span class="stat-value" id="callCount">0</span></div>
                <div class="stat">Returns: <span class="stat-value" id="returnCount">0</span></div>
                <div class="stat">Max Depth: <span class="stat-value" id="maxDepth">0</span></div>
            </div>
            <div class="panel-content" id="traceOutput">
                <div class="empty-state">Run code to see trace</div>
            </div>
        </div>
        
        <div class="panel">
            <div class="panel-header">üéØ Generated Exercises</div>
            <div class="stats-bar">
                <div class="stat">Score: <span class="stat-value" id="score">0</span>/<span id="total">0</span></div>
            </div>
            <div class="panel-content" id="exerciseOutput">
                <div class="empty-state">Run code to generate exercises</div>
            </div>
        </div>
    </div>

    <script>
        let traceData = [];
        let callStack = [];
        let stats = { calls: 0, returns: 0, maxDepth: 0 };
        let score = 0;
        let totalQuizzes = 0;
        let currentLang = 'js';
        let pyodide = null;
        let pythonReady = false;

        function switchLang(lang) {
            currentLang = lang;
            document.querySelectorAll('.lang-tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');
            document.querySelectorAll('.editor-panel').forEach(panel => panel.classList.remove('active'));
            document.getElementById(lang === 'js' ? 'jsEditor' : 'pythonEditor').classList.add('active');
            
            if (lang === 'python' && !pythonReady) {
                loadPyodideRuntime();
            }
        }

        async function loadPyodideRuntime() {
            if (pyodide) return;
            const output = document.getElementById('traceOutput');
            output.innerHTML = '<div style="color: #4fc3f7; padding: 20px;">‚è≥ Loading Python (~10MB)...</div>';
            
            try {
                pyodide = await loadPyodide({ 
                    indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.24.1/full/' 
                });
                
                await pyodide.runPythonAsync(`
import sys
import json
from js import addPythonSnapshot

def trace_function(frame, event, arg):
    func_name = frame.f_code.co_name
    filename = frame.f_code.co_filename
    
    if 'exec' not in filename or func_name == 'trace_function':
        return trace_function
    
    if event == 'call':
        args = list(frame.f_locals.values())
        addPythonSnapshot(json.dumps({
            'type': 'call',
            'name': func_name,
            'args': [str(v) for v in args],
            'depth': len([f for f in sys._current_frames().values()])
        }))
    elif event == 'return':
        addPythonSnapshot(json.dumps({
            'type': 'return',
            'name': func_name,
            'value': str(arg) if arg is not None else 'None'
        }))
    
    return trace_function

sys.settrace(trace_function)
                `);
                pythonReady = true;
                output.innerHTML = '<div style="color: #48bb78; padding: 20px;">‚úì Python ready!</div>';
            } catch (e) {
                output.innerHTML = '<div style="color: #f44336; padding: 20px;">‚úó Error: ' + e.message + '</div>';
            }
        }

        window.addPythonSnapshot = function(jsonStr) {
            const data = JSON.parse(jsonStr);
            if (data.type === 'call') {
                const depth = callStack.length;
                stats.calls++;
                stats.maxDepth = Math.max(stats.maxDepth, depth);
                callStack.push(data.name);
                traceData.push({ type: 'call', name: data.name, args: data.args, depth, timestamp: traceData.length });
            } else {
                stats.returns++;
                const depth = callStack.length - 1;
                traceData.push({ type: 'return', name: data.name, value: data.value, depth, timestamp: traceData.length });
                callStack.pop();
            }
        };
        
        // Babel plugin for automatic tracing
        function tracePlugin({ types: t }) {
            return {
                visitor: {
                    FunctionDeclaration(path) { instrumentFunction(path, t); },
                    FunctionExpression(path) { instrumentFunction(path, t); },
                    ArrowFunctionExpression(path) { instrumentFunction(path, t); }
                }
            };
        }

        function instrumentFunction(path, t) {
            const funcName = path.node.id?.name || 'anonymous';
            const params = path.node.params.map(p => p.name || 'arg');
            const body = path.node.body;
            if (body.body?.[0]?.expression?.callee?.name === '__traceCall') return;
            const traceCallNode = t.expressionStatement(
                t.callExpression(t.identifier('__traceCall'), [
                    t.stringLiteral(funcName),
                    t.arrayExpression(params.map(p => t.identifier(p)))
                ])
            );
            path.traverse({
                ReturnStatement(returnPath) {
                    const arg = returnPath.node.argument;
                    returnPath.node.argument = t.callExpression(
                        t.identifier('__traceReturn'),
                        [t.stringLiteral(funcName), arg || t.identifier('undefined')]
                    );
                }
            });
            if (body.type === 'BlockStatement') {
                body.body.unshift(traceCallNode);
            }
        }

        window.__traceCall = function(name, args) {
            const depth = callStack.length;
            stats.calls++;
            stats.maxDepth = Math.max(stats.maxDepth, depth);
            callStack.push(name);
            traceData.push({ type: 'call', name, args, depth, timestamp: traceData.length });
        };

        window.__traceReturn = function(name, value) {
            const depth = callStack.length - 1;
            stats.returns++;
            traceData.push({ type: 'return', name, value, depth, timestamp: traceData.length });
            callStack.pop();
            return value;
        };
        
        function trace(fn, name) {
            return function(...args) {
                const depth = callStack.length;
                stats.calls++;
                stats.maxDepth = Math.max(stats.maxDepth, depth);
                callStack.push(name);
                
                traceData.push({
                    type: 'call',
                    name: name,
                    args: args,
                    depth: depth,
                    timestamp: traceData.length
                });
                
                let result;
                try {
                    result = fn.apply(this, args);
                } catch (e) {
                    callStack.pop();
                    throw e;
                }
                
                stats.returns++;
                traceData.push({
                    type: 'return',
                    name: name,
                    value: result,
                    depth: depth,
                    timestamp: traceData.length
                });
                
                callStack.pop();
                return result;
            };
        }
        
        function runAndGenerate() {
            // Reset
            traceData = [];
            callStack = [];
            stats = { calls: 0, returns: 0, maxDepth: 0 };
            score = 0;
            totalQuizzes = 0;
            
            if (currentLang === 'js') {
                runJavaScript();
            } else {
                runPython();
            }
        }

        function runJavaScript() {
            const code = document.getElementById('jsCode').value;
            
            try {
                const transformed = Babel.transform(code, {
                    plugins: [tracePlugin]
                }).code;
                eval(transformed);
                
                updateStats();
                renderTrace();
                generateExercises();
                
            } catch (e) {
                document.getElementById('traceOutput').innerHTML = 
                    `<div class="quiz-feedback feedback-incorrect">Error: ${e.message}</div>`;
            }
        }

        async function runPython() {
            if (!pythonReady) {
                document.getElementById('traceOutput').innerHTML = '<div style="color: #f44336; padding: 20px;">‚è≥ Python still loading...</div>';
                return;
            }

            const code = document.getElementById('pythonCode').value;
            
            try {
                await pyodide.runPythonAsync('import sys; sys.settrace(trace_function)');
                await pyodide.runPythonAsync(code);
                await pyodide.runPythonAsync('sys.settrace(None)');
                
                updateStats();
                renderTrace();
                generateExercises();
                
            } catch (e) {
                document.getElementById('traceOutput').innerHTML = 
                    `<div class="quiz-feedback feedback-incorrect">Error: ${e.message}</div>`;
            }
        }

        function updateStats() {
            document.getElementById('callCount').textContent = stats.calls;
            document.getElementById('returnCount').textContent = stats.returns;
            document.getElementById('maxDepth').textContent = stats.maxDepth;
        }
        
        function renderTrace() {
            const output = document.getElementById('traceOutput');
            output.innerHTML = traceData.map(t => {
                const indent = '  '.repeat(t.depth);
                const icon = t.type === 'call' ? '‚Üí' : '‚Üê';
                const content = t.type === 'call' 
                    ? `${t.name}(${t.args.join(', ')})`
                    : `${t.name}() = ${t.value}`;
                return `<div class="trace-item trace-${t.type}">${indent}${icon} ${content}</div>`;
            }).join('');
        }
        
        function generateExercises() {
            const output = document.getElementById('exerciseOutput');
            const quizzes = [];
            
            // Get unique function names and their calls
            const calls = traceData.filter(t => t.type === 'call');
            const returns = traceData.filter(t => t.type === 'return');
            const funcNames = [...new Set(calls.map(c => c.name))];
            
            // 1. Call Count Quiz
            if (funcNames.length > 0) {
                const func = funcNames[0];
                const count = calls.filter(c => c.name === func).length;
                const options = shuffleArray([count, count + 2, count - 1, count * 2].filter(n => n > 0));
                quizzes.push(createMultipleChoice(
                    'Call Count',
                    `How many times was <code>${func}()</code> called?`,
                    options.slice(0, 4),
                    count
                ));
            }
            
            // 2. Return Value Quiz
            if (returns.length > 0) {
                const ret = returns[Math.floor(returns.length / 2)];
                const call = calls.find(c => c.name === ret.name && c.args.length > 0);
                if (call) {
                    const options = shuffleArray([ret.value, ret.value + 1, ret.value - 1, ret.value * 2]);
                    quizzes.push(createMultipleChoice(
                        'Return Value',
                        `What did <code>${ret.name}(${call.args.join(', ')})</code> return?`,
                        options.slice(0, 4),
                        ret.value
                    ));
                }
            }
            
            // 3. Argument Tracking Quiz
            if (calls.length >= 3) {
                const idx = Math.min(2, calls.length - 1);
                const call = calls[idx];
                if (call.args.length > 0) {
                    quizzes.push(createInputQuiz(
                        'Argument Tracking',
                        `What was the argument in the ${ordinal(idx + 1)} call to <code>${call.name}()</code>?`,
                        String(call.args[0])
                    ));
                }
            }
            
            // 4. Timeline Matching Quiz
            if (calls.length >= 2) {
                const first = calls[0];
                const second = calls[Math.min(1, calls.length - 1)];
                if (first.name !== second.name || first.args[0] !== second.args[0]) {
                    quizzes.push(createMultipleChoice(
                        'Timeline',
                        `Which happened first?`,
                        [
                            `${first.name}(${first.args.join(', ')})`,
                            `${second.name}(${second.args.join(', ')})`
                        ],
                        `${first.name}(${first.args.join(', ')})`
                    ));
                }
            }
            
            // 5. Execution Order Quiz (Parsons-style)
            if (calls.length >= 3) {
                const subset = calls.slice(0, Math.min(4, calls.length));
                const items = subset.map(c => `${c.name}(${c.args.join(', ')})`);
                quizzes.push(createSortableQuiz(
                    'Execution Order',
                    'Arrange these calls in the order they were executed:',
                    items
                ));
            }
            
            totalQuizzes = quizzes.length;
            document.getElementById('total').textContent = totalQuizzes;
            document.getElementById('score').textContent = score;
            
            output.innerHTML = quizzes.join('');
            
            // Initialize sortable
            initSortable();
        }
        
        function createMultipleChoice(type, question, options, correct) {
            const id = 'quiz-' + Math.random().toString(36).substr(2, 9);
            return `
                <div class="quiz-card" id="${id}" data-correct="${correct}">
                    <div class="quiz-type">${type}</div>
                    <div class="quiz-question">${question}</div>
                    <div class="quiz-options">
                        ${options.map(opt => `
                            <div class="quiz-option" onclick="checkAnswer('${id}', '${opt}', this)">${opt}</div>
                        `).join('')}
                    </div>
                    <div class="quiz-feedback" style="display: none;"></div>
                </div>
            `;
        }
        
        function createInputQuiz(type, question, correct) {
            const id = 'quiz-' + Math.random().toString(36).substr(2, 9);
            return `
                <div class="quiz-card" id="${id}" data-correct="${correct}">
                    <div class="quiz-type">${type}</div>
                    <div class="quiz-question">${question}</div>
                    <input type="text" class="quiz-input" placeholder="Your answer..." 
                           onkeypress="if(event.key==='Enter') checkInputAnswer('${id}', this.value)">
                    <button class="check-btn" onclick="checkInputAnswer('${id}', this.previousElementSibling.value)">Check</button>
                    <div class="quiz-feedback" style="display: none;"></div>
                </div>
            `;
        }
        
        function createSortableQuiz(type, question, items) {
            const id = 'quiz-' + Math.random().toString(36).substr(2, 9);
            const correctOrder = [...items];
            const shuffled = shuffleArray([...items]);
            return `
                <div class="quiz-card" id="${id}" data-correct='${JSON.stringify(correctOrder)}'>
                    <div class="quiz-type">${type}</div>
                    <div class="quiz-question">${question}</div>
                    <div class="sortable-list" id="sortable-${id}">
                        ${shuffled.map(item => `
                            <div class="sortable-item" draggable="true">${item}</div>
                        `).join('')}
                    </div>
                    <button class="check-btn" onclick="checkSortableAnswer('${id}')">Check Order</button>
                    <div class="quiz-feedback" style="display: none;"></div>
                </div>
            `;
        }
        
        function checkAnswer(quizId, answer, element) {
            const card = document.getElementById(quizId);
            if (card.classList.contains('correct') || card.classList.contains('incorrect')) return;
            
            const correct = card.dataset.correct;
            const feedback = card.querySelector('.quiz-feedback');
            const options = card.querySelectorAll('.quiz-option');
            
            options.forEach(opt => {
                if (opt.textContent == correct) opt.classList.add('correct-answer');
            });
            
            if (String(answer) === String(correct)) {
                card.classList.add('correct');
                element.classList.add('correct-answer');
                feedback.className = 'quiz-feedback feedback-correct';
                feedback.textContent = '‚úì Correct!';
                score++;
            } else {
                card.classList.add('incorrect');
                element.classList.add('wrong-answer');
                feedback.className = 'quiz-feedback feedback-incorrect';
                feedback.textContent = `‚úó Incorrect. The answer was ${correct}`;
            }
            
            feedback.style.display = 'block';
            document.getElementById('score').textContent = score;
        }
        
        function checkInputAnswer(quizId, answer) {
            const card = document.getElementById(quizId);
            if (card.classList.contains('correct') || card.classList.contains('incorrect')) return;
            
            const correct = card.dataset.correct;
            const feedback = card.querySelector('.quiz-feedback');
            
            if (String(answer).trim() === String(correct)) {
                card.classList.add('correct');
                feedback.className = 'quiz-feedback feedback-correct';
                feedback.textContent = '‚úì Correct!';
                score++;
            } else {
                card.classList.add('incorrect');
                feedback.className = 'quiz-feedback feedback-incorrect';
                feedback.textContent = `‚úó Incorrect. The answer was ${correct}`;
            }
            
            feedback.style.display = 'block';
            document.getElementById('score').textContent = score;
        }
        
        function checkSortableAnswer(quizId) {
            const card = document.getElementById(quizId);
            if (card.classList.contains('correct') || card.classList.contains('incorrect')) return;
            
            const correct = JSON.parse(card.dataset.correct);
            const list = document.getElementById('sortable-' + quizId);
            const items = [...list.querySelectorAll('.sortable-item')].map(el => el.textContent);
            const feedback = card.querySelector('.quiz-feedback');
            
            const isCorrect = JSON.stringify(items) === JSON.stringify(correct);
            
            if (isCorrect) {
                card.classList.add('correct');
                feedback.className = 'quiz-feedback feedback-correct';
                feedback.textContent = '‚úì Correct order!';
                score++;
            } else {
                card.classList.add('incorrect');
                feedback.className = 'quiz-feedback feedback-incorrect';
                feedback.textContent = `‚úó Incorrect. Correct order: ${correct.join(' ‚Üí ')}`;
            }
            
            feedback.style.display = 'block';
            document.getElementById('score').textContent = score;
        }
        
        function initSortable() {
            document.querySelectorAll('.sortable-list').forEach(list => {
                let draggedItem = null;
                
                list.querySelectorAll('.sortable-item').forEach(item => {
                    item.addEventListener('dragstart', () => {
                        draggedItem = item;
                        item.classList.add('dragging');
                    });
                    
                    item.addEventListener('dragend', () => {
                        item.classList.remove('dragging');
                        draggedItem = null;
                    });
                    
                    item.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        if (draggedItem && draggedItem !== item) {
                            const rect = item.getBoundingClientRect();
                            const midY = rect.top + rect.height / 2;
                            if (e.clientY < midY) {
                                list.insertBefore(draggedItem, item);
                            } else {
                                list.insertBefore(draggedItem, item.nextSibling);
                            }
                        }
                    });
                });
            });
        }
        
        function shuffleArray(arr) {
            const shuffled = [...arr];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }
        
        function ordinal(n) {
            const s = ['th', 'st', 'nd', 'rd'];
            const v = n % 100;
            return n + (s[(v - 20) % 10] || s[v] || s[0]);
        }
        
        async function runWithLLM() {
            // Reset and run trace
            traceData = [];
            callStack = [];
            stats = { calls: 0, returns: 0, maxDepth: 0 };
            score = 0;
            totalQuizzes = 0;
            
            if (currentLang === 'js') {
                const code = document.getElementById('jsCode').value;
                try {
                    const transformed = Babel.transform(code, {
                        plugins: [tracePlugin]
                    }).code;
                    eval(transformed);
                    updateStats();
                    renderTrace();
                    await generateWithLLM(code);
                } catch (e) {
                    document.getElementById('traceOutput').innerHTML = 
                        `<div class="quiz-feedback feedback-incorrect">Error: ${e.message}</div>`;
                }
            } else {
                if (!pythonReady) {
                    document.getElementById('traceOutput').innerHTML = '<div style="color: #f44336; padding: 20px;">‚è≥ Python still loading...</div>';
                    return;
                }
                const code = document.getElementById('pythonCode').value;
                try {
                    await pyodide.runPythonAsync('import sys; sys.settrace(trace_function)');
                    await pyodide.runPythonAsync(code);
                    await pyodide.runPythonAsync('sys.settrace(None)');
                    updateStats();
                    renderTrace();
                    await generateWithLLM(code);
                } catch (e) {
                    document.getElementById('traceOutput').innerHTML = 
                        `<div class="quiz-feedback feedback-incorrect">Error: ${e.message}</div>`;
                }
            }
        }
        
        async function generateWithLLM(code) {
            const output = document.getElementById('exerciseOutput');
            output.innerHTML = '<div class="empty-state">ü§ñ Generating AI questions...</div>';
            
            // Summarize trace for LLM
            const calls = traceData.filter(t => t.type === 'call');
            const returns = traceData.filter(t => t.type === 'return');
            const funcNames = [...new Set(calls.map(c => c.name))];
            
            const traceSummary = {
                functions: funcNames,
                totalCalls: calls.length,
                maxDepth: stats.maxDepth,
                callSequence: calls.slice(0, 10).map(c => `${c.name}(${c.args.join(',')})`),
                returnValues: returns.slice(0, 10).map(r => ({ func: r.name, value: r.value }))
            };
            
            const aiPrompt = `You are a programming education expert. Given this code and its execution trace, generate 5 unique quiz questions to test understanding.

CODE:
\`\`\`
${code}
\`\`\`

EXECUTION TRACE SUMMARY:
- Functions called: ${traceSummary.functions.join(', ')}
- Total function calls: ${traceSummary.totalCalls}
- Maximum recursion depth: ${traceSummary.maxDepth}
- Call sequence (first 10): ${traceSummary.callSequence.join(' ‚Üí ')}
- Return values (sample): ${JSON.stringify(traceSummary.returnValues)}

Generate 5 varied questions. Mix these types:
1. Counting (how many calls, returns, etc.)
2. Sequence (what order did things happen)
3. Values (what was returned, what arguments)
4. Reasoning (why did X happen before Y)
5. Prediction (if input was Z, what would happen)

Return ONLY valid JSON array:
[
  {
    "type": "multiple_choice",
    "question": "...",
    "options": ["A", "B", "C", "D"],
    "correct": 0
  },
  {
    "type": "input",
    "question": "...",
    "answer": "..."
  }
]`;

            try {
                const response = await fetch('/api/ai', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt: aiPrompt, forceJSON: true })
                });
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                const content = data.content;
                
                // Parse JSON from response
                const jsonMatch = content.match(/\[[\s\S]*\]/);
                if (!jsonMatch) throw new Error('No JSON found in response');
                
                const questions = JSON.parse(jsonMatch[0]);
                renderLLMQuizzes(questions);
                
            } catch (e) {
                output.innerHTML = `<div class="quiz-feedback feedback-incorrect">LLM Error: ${e.message}</div>`;
            }
        }
        
        function renderLLMQuizzes(questions) {
            const output = document.getElementById('exerciseOutput');
            totalQuizzes = questions.length;
            document.getElementById('total').textContent = totalQuizzes;
            
            output.innerHTML = questions.map((q, i) => {
                const id = 'llm-quiz-' + i;
                
                if (q.type === 'multiple_choice') {
                    return `
                        <div class="quiz-card" id="${id}" data-correct="${q.correct}">
                            <div class="quiz-type">ü§ñ AI Generated - Multiple Choice</div>
                            <div class="quiz-question">${q.question}</div>
                            <div class="quiz-options">
                                ${q.options.map((opt, j) => `
                                    <div class="quiz-option" onclick="checkLLMAnswer('${id}', ${j}, this)">${opt}</div>
                                `).join('')}
                            </div>
                            <div class="quiz-feedback" style="display: none;"></div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="quiz-card" id="${id}" data-correct="${q.answer}">
                            <div class="quiz-type">ü§ñ AI Generated - Input</div>
                            <div class="quiz-question">${q.question}</div>
                            <input type="text" class="quiz-input" placeholder="Your answer...">
                            <button class="check-btn" onclick="checkLLMInput('${id}', this)">Check</button>
                            <div class="quiz-feedback" style="display: none;"></div>
                        </div>
                    `;
                }
            }).join('');
        }
        
        function checkLLMAnswer(quizId, selected, element) {
            const card = document.getElementById(quizId);
            if (card.classList.contains('correct') || card.classList.contains('incorrect')) return;
            
            const correct = parseInt(card.dataset.correct);
            const feedback = card.querySelector('.quiz-feedback');
            const options = card.querySelectorAll('.quiz-option');
            
            options[correct].classList.add('correct-answer');
            
            if (selected === correct) {
                card.classList.add('correct');
                element.classList.add('correct-answer');
                feedback.className = 'quiz-feedback feedback-correct';
                feedback.textContent = '‚úì Correct!';
                score++;
            } else {
                card.classList.add('incorrect');
                element.classList.add('wrong-answer');
                feedback.className = 'quiz-feedback feedback-incorrect';
                feedback.textContent = '‚úó Incorrect';
            }
            
            feedback.style.display = 'block';
            document.getElementById('score').textContent = score;
        }
        
        function checkLLMInput(quizId, btn) {
            const card = document.getElementById(quizId);
            if (card.classList.contains('correct') || card.classList.contains('incorrect')) return;
            
            const input = card.querySelector('.quiz-input');
            const correct = card.dataset.correct.toLowerCase().trim();
            const answer = input.value.toLowerCase().trim();
            const feedback = card.querySelector('.quiz-feedback');
            
            if (answer === correct || answer.includes(correct) || correct.includes(answer)) {
                card.classList.add('correct');
                feedback.className = 'quiz-feedback feedback-correct';
                feedback.textContent = '‚úì Correct!';
                score++;
            } else {
                card.classList.add('incorrect');
                feedback.className = 'quiz-feedback feedback-incorrect';
                feedback.textContent = `‚úó Incorrect. Answer: ${card.dataset.correct}`;
            }
            
            feedback.style.display = 'block';
            document.getElementById('score').textContent = score;
        }
    </script>
</body>
</html>
