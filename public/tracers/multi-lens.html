<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Lens Code Viewer</title>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #1e1e1e; color: #d4d4d4; height: 100vh; display: flex; flex-direction: column; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; }
        .header h1 { font-size: 18px; }
        .lens-tabs { display: flex; gap: 5px; background: rgba(0,0,0,0.2); padding: 5px; border-radius: 8px; }
        .tab { padding: 8px 16px; background: transparent; border: none; color: rgba(255,255,255,0.7); cursor: pointer; border-radius: 6px; font-weight: 600; font-size: 13px; }
        .tab.active { background: rgba(255,255,255,0.2); color: white; }
        .tab:hover { background: rgba(255,255,255,0.1); }
        .workspace { flex: 1; display: grid; grid-template-columns: 1fr 1fr; gap: 0; overflow: hidden; }
        .panel { background: #252526; border: 1px solid #3e3e42; display: flex; flex-direction: column; overflow: hidden; }
        .panel-header { background: #2d2d30; color: #ccc; padding: 10px 15px; font-weight: 600; font-size: 13px; border-bottom: 1px solid #3e3e42; }
        .panel-content { flex: 1; overflow: auto; padding: 15px; }
        .code-editor { width: 100%; height: 100%; min-height: 300px; background: #1e1e1e; color: #d4d4d4; border: none; padding: 15px; font-family: 'Consolas', monospace; font-size: 14px; line-height: 1.6; resize: none; outline: none; }
        .lens-view { background: #1e1e1e; padding: 15px; height: 100%; overflow: auto; }
        pre { background: #2d2d30; padding: 15px; border-radius: 6px; overflow-x: auto; font-size: 13px; line-height: 1.6; }
        .keyword { color: #569cd6; }
        .function { color: #dcdcaa; }
        .string { color: #ce9178; }
        .number { color: #b5cea8; }
        .comment { color: #6a9955; }
        .trace-item { background: #2d2d30; margin: 6px 0; padding: 10px; border-radius: 4px; border-left: 3px solid #4fc3f7; font-family: monospace; font-size: 12px; }
        .trace-call { border-left-color: #66bb6a; }
        .trace-return { border-left-color: #ffa726; }
        .parsons-container { display: flex; flex-direction: column; gap: 8px; }
        .parsons-block { background: #2d2d30; padding: 10px 15px; border-radius: 6px; cursor: grab; font-family: monospace; font-size: 13px; border: 2px solid transparent; transition: all 0.2s; }
        .parsons-block:hover { border-color: #667eea; }
        .parsons-block.dragging { opacity: 0.5; }
        .parsons-dropzone { min-height: 200px; background: #1a1a1a; border: 2px dashed #3e3e42; border-radius: 8px; padding: 15px; }
        .parsons-dropzone.over { border-color: #667eea; background: rgba(102, 126, 234, 0.1); }
        .var-table { width: 100%; border-collapse: collapse; }
        .var-table th, .var-table td { padding: 10px; text-align: left; border-bottom: 1px solid #3e3e42; font-family: monospace; font-size: 13px; }
        .var-table th { background: #2d2d30; color: #9cdcfe; }
        .var-value { color: #ce9178; }
        .ast-node { margin-left: 20px; padding: 5px 0; }
        .ast-type { color: #4ec9b0; font-weight: bold; }
        .ast-prop { color: #9cdcfe; }
        .blanks-code { font-family: monospace; font-size: 14px; line-height: 2; }
        .blank-input { background: #3e3e42; border: 1px solid #569cd6; color: #d4d4d4; padding: 2px 8px; border-radius: 4px; font-family: monospace; width: 100px; }
        .blank-input.correct { border-color: #66bb6a; background: rgba(102, 187, 106, 0.2); }
        .blank-input.incorrect { border-color: #f44336; background: rgba(244, 67, 54, 0.2); }
        .btn { padding: 8px 16px; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 13px; }
        .btn-primary { background: #667eea; color: white; }
        .btn-success { background: #66bb6a; color: white; }
        .controls { display: flex; gap: 10px; margin-bottom: 15px; }
        .indent-1 { margin-left: 20px; }
        .indent-2 { margin-left: 40px; }
        .indent-3 { margin-left: 60px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>üîç Multi-Lens Code Viewer</h1>
        <div class="lens-tabs">
            <button class="tab active" onclick="switchLens('study')">üìñ Study</button>
            <button class="tab" onclick="switchLens('trace')">üîç Trace</button>
            <button class="tab" onclick="switchLens('parsons')">üß© Parsons</button>
            <button class="tab" onclick="switchLens('variables')">üìä Variables</button>
            <button class="tab" onclick="switchLens('ast')">üå≥ AST</button>
            <button class="tab" onclick="switchLens('blanks')">‚úèÔ∏è Blanks</button>
        </div>
    </div>
    
    <div class="workspace">
        <div class="panel">
            <div class="panel-header">üìù Source Code</div>
            <div class="panel-content">
                <textarea class="code-editor" id="codeEditor" oninput="updateAllLenses()">// Write your JavaScript code here
function greet(name) {
    return "Hello, " + name + "!";
}

function add(a, b) {
    return a + b;
}

const result = add(3, 4);
console.log(greet("World"));
console.log("Result:", result);</textarea>
            </div>
        </div>
        
        <div class="panel">
            <div class="panel-header" id="lensHeader">üìñ Study Lens</div>
            <div class="panel-content">
                <div class="lens-view" id="lensView"></div>
            </div>
        </div>
    </div>

    <script>
        let currentLens = 'study';
        let traceData = [];
        let callStack = [];
        
        // Babel plugin for automatic tracing
        function tracePlugin({ types: t }) {
            return {
                visitor: {
                    FunctionDeclaration(path) { instrumentFunction(path, t); },
                    FunctionExpression(path) { instrumentFunction(path, t); },
                    ArrowFunctionExpression(path) { instrumentFunction(path, t); }
                }
            };
        }

        function instrumentFunction(path, t) {
            const funcName = path.node.id?.name || 'anonymous';
            const params = path.node.params.map(p => p.name || 'arg');
            const body = path.node.body;
            if (body.body?.[0]?.expression?.callee?.name === '__traceCall') return;
            const traceCallNode = t.expressionStatement(
                t.callExpression(t.identifier('__traceCall'), [
                    t.stringLiteral(funcName),
                    t.arrayExpression(params.map(p => t.identifier(p)))
                ])
            );
            path.traverse({
                ReturnStatement(returnPath) {
                    const arg = returnPath.node.argument;
                    returnPath.node.argument = t.callExpression(
                        t.identifier('__traceReturn'),
                        [t.stringLiteral(funcName), arg || t.identifier('undefined')]
                    );
                }
            });
            if (body.type === 'BlockStatement') {
                body.body.unshift(traceCallNode);
            }
        }

        window.__traceCall = function(name, args) {
            const depth = callStack.length;
            callStack.push(name);
            traceData.push(`<div class="trace-item trace-call">${'  '.repeat(depth)}‚Üí CALL ${name}(${args.map(a => JSON.stringify(a)).join(', ')})</div>`);
        };

        window.__traceReturn = function(name, value) {
            const depth = callStack.length - 1;
            traceData.push(`<div class="trace-item trace-return">${'  '.repeat(depth)}‚Üê RETURN ${name}() ‚Üí ${JSON.stringify(value)}</div>`);
            callStack.pop();
            return value;
        };
        
        function switchLens(lens) {
            currentLens = lens;
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            
            const headers = { study: 'üìñ Study Lens', trace: 'üîç Trace Lens', parsons: 'üß© Parsons Lens', variables: 'üìä Variables Lens', ast: 'üå≥ AST Lens', blanks: '‚úèÔ∏è Blanks Lens' };
            document.getElementById('lensHeader').textContent = headers[lens];
            updateAllLenses();
        }
        
        function updateAllLenses() {
            const code = document.getElementById('codeEditor').value;
            const view = document.getElementById('lensView');
            
            switch(currentLens) {
                case 'study': view.innerHTML = renderStudy(code); break;
                case 'trace': view.innerHTML = renderTrace(code); break;
                case 'parsons': view.innerHTML = renderParsons(code); break;
                case 'variables': view.innerHTML = renderVariables(code); break;
                case 'ast': view.innerHTML = renderAST(code); break;
                case 'blanks': view.innerHTML = renderBlanks(code); break;
            }
        }
        
        function renderStudy(code) {
            const highlighted = code
                .replace(/\b(function|const|let|var|if|else|return|for|while)\b/g, '<span class="keyword">$1</span>')
                .replace(/\b(\d+)\b/g, '<span class="number">$1</span>')
                .replace(/(["'`].*?["'`])/g, '<span class="string">$1</span>')
                .replace(/\/\/.*/g, '<span class="comment">$&</span>')
                .replace(/\b(\w+)\s*\(/g, '<span class="function">$1</span>(');
            return `<pre>${highlighted}</pre><p style="margin-top:15px;color:#858585;">Read and understand the code structure. Notice the function definition, conditionals, and recursive calls.</p>`;
        }
        
        function renderTrace(code) {
            let html = '<div class="controls"><button class="btn btn-primary" onclick="runTrace()">‚ñ∂Ô∏è Run Trace</button></div>';
            html += '<div id="traceOutput"><p style="color:#858585;">Click "Run Trace" to see execution steps.</p></div>';
            return html;
        }
        
        function renderParsons(code) {
            const lines = code.split('\n').filter(l => l.trim());
            const shuffled = [...lines].sort(() => Math.random() - 0.5);
            
            let html = '<p style="margin-bottom:15px;color:#858585;">Drag the code blocks into the correct order:</p>';
            html += '<div class="parsons-container" id="parsonsSource">';
            shuffled.forEach((line, i) => {
                html += `<div class="parsons-block" draggable="true" ondragstart="dragStart(event)" ondragend="dragEnd(event)" data-line="${i}">${escapeHtml(line)}</div>`;
            });
            html += '</div>';
            html += '<p style="margin:15px 0;color:#858585;">Drop here in correct order:</p>';
            html += '<div class="parsons-dropzone" id="parsonsTarget" ondragover="dragOver(event)" ondrop="drop(event)"></div>';
            html += '<div class="controls" style="margin-top:15px;"><button class="btn btn-success" onclick="checkParsons()">‚úì Check Order</button></div>';
            return html;
        }
        
        function renderVariables(code) {
            let html = '<div class="controls"><button class="btn btn-primary" onclick="runVariables()">‚ñ∂Ô∏è Run & Track Variables</button><button class="btn" style="background:#3e3e42;color:#ccc;margin-left:5px;" onclick="stepVariables()">‚è≠Ô∏è Step</button></div>';
            html += '<div id="varTimeline" style="margin-bottom:15px;"></div>';
            html += '<table class="var-table"><thead><tr><th>Scope</th><th>Variable</th><th>Value</th><th>Type</th><th>Changed</th></tr></thead><tbody id="varBody">';
            html += '<tr><td colspan="5" style="color:#858585;text-align:center;">Click "Run" to see variable states</td></tr>';
            html += '</tbody></table>';
            return html;
        }
        
        function renderAST(code) {
            let html = '<p style="margin-bottom:15px;color:#858585;">Abstract Syntax Tree representation:</p>';
            try {
                const simplified = parseSimpleAST(code);
                html += '<div style="font-family:monospace;font-size:13px;">' + simplified + '</div>';
            } catch(e) {
                html += '<p style="color:#f44336;">Error parsing code: ' + e.message + '</p>';
            }
            return html;
        }
        
        function renderBlanks(code) {
            const keywords = ['function', 'const', 'let', 'var', 'if', 'else', 'return', 'for', 'while'];
            let blanksCode = code;
            
            // Replace function names
            blanksCode = blanksCode.replace(/function\s+(\w+)/g, (match, name) => {
                return `function <input class="blank-input" data-answer="${name}" placeholder="?" size="8">`;
            });
            
            // Replace variable names in declarations
            blanksCode = blanksCode.replace(/(const|let|var)\s+(\w+)/g, (match, keyword, name) => {
                return `${keyword} <input class="blank-input" data-answer="${name}" placeholder="?" size="8">`;
            });
            
            // Replace numbers
            blanksCode = blanksCode.replace(/\b(\d+)\b/g, (match, num) => {
                return `<input class="blank-input" data-answer="${num}" placeholder="?" size="3">`;
            });
            
            let html = '<p style="margin-bottom:15px;color:#858585;">Fill in the blanks:</p>';
            html += '<div class="blanks-code"><pre>' + blanksCode + '</pre></div>';
            html += '<div class="controls" style="margin-top:15px;"><button class="btn btn-success" onclick="checkBlanks()">‚úì Check Answers</button></div>';
            return html;
        }
        
        function parseSimpleAST(code) {
            try {
                const result = Babel.transform(code, { ast: true, code: false });
                const ast = result.ast.program;
                return renderASTNode(ast, 0);
            } catch (e) {
                return `<div style="color:#f44336;">Parse error: ${e.message}</div>`;
            }
        }
        
        function renderASTNode(node, depth) {
            if (!node) return '';
            const indent = '  '.repeat(depth);
            let html = `<div class="ast-node"><span class="ast-type">${node.type}</span>`;
            
            if (node.type === 'FunctionDeclaration' && node.id) {
                html += ` <span class="ast-prop">name: "${node.id.name}"</span>`;
            }
            if (node.type === 'Identifier') {
                html += ` <span class="ast-prop">"${node.name}"</span>`;
            }
            if (node.type === 'NumericLiteral' || node.type === 'StringLiteral') {
                html += ` <span class="ast-prop">${JSON.stringify(node.value)}</span>`;
            }
            
            const childKeys = ['body', 'consequent', 'alternate', 'test', 'left', 'right', 'argument', 'callee', 'arguments', 'params'];
            for (const key of childKeys) {
                if (node[key]) {
                    if (Array.isArray(node[key])) {
                        node[key].forEach(child => html += renderASTNode(child, depth + 1));
                    } else {
                        html += renderASTNode(node[key], depth + 1);
                    }
                }
            }
            
            html += '</div>';
            return html;
        }
        
        function escapeHtml(str) {
            return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
        }
        
        // Parsons drag and drop
        let draggedElement = null;
        
        function dragStart(e) {
            draggedElement = e.target;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }
        
        function dragEnd(e) {
            e.target.classList.remove('dragging');
        }
        
        function dragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }
        
        function drop(e) {
            e.preventDefault();
            if (draggedElement && e.target.classList.contains('parsons-dropzone')) {
                e.target.appendChild(draggedElement);
            }
        }
        
        function checkParsons() {
            const original = document.getElementById('codeEditor').value.split('\n').filter(l => l.trim());
            const target = document.getElementById('parsonsTarget');
            const blocks = Array.from(target.querySelectorAll('.parsons-block'));
            const userOrder = blocks.map(b => b.textContent.trim());
            
            let correct = true;
            blocks.forEach((block, i) => {
                if (userOrder[i] === original[i]) {
                    block.style.borderLeft = '3px solid #66bb6a';
                } else {
                    block.style.borderLeft = '3px solid #f44336';
                    correct = false;
                }
            });
            
            if (correct && userOrder.length === original.length) {
                alert('‚úì Perfect! All lines in correct order!');
            } else {
                alert('‚úó Not quite right. Try again!');
            }
        }
        function checkBlanks() {
            document.querySelectorAll('.blank-input').forEach(input => {
                input.classList.remove('correct', 'incorrect');
                input.classList.add(input.value === input.dataset.answer ? 'correct' : 'incorrect');
            });
        }
        
        function runTrace() {
            const output = document.getElementById('traceOutput');
            const code = document.getElementById('codeEditor').value;
            traceData = [];
            callStack = [];
            
            try {
                const transformed = Babel.transform(code, {
                    plugins: [tracePlugin]
                }).code;
                eval(transformed);
                output.innerHTML = traceData.length ? traceData.join('') : '<div style="color: #858585; text-align: center; padding: 40px;">No function calls traced.</div>';
            } catch (e) {
                output.innerHTML = `<div style="color: #f44336; padding: 20px;">Error: ${e.message}</div>`;
            }
        }
        
        let varStep = 0;
        let varHistory = [];
        let varSnapshot = {};
        
        window.__trackVar = function(scope, name, value) {
            const key = `${scope}.${name}`;
            const oldVal = varSnapshot[key];
            const changed = oldVal !== value;
            varSnapshot[key] = value;
            
            const existing = varHistory.find(h => h.scope === scope);
            if (existing) {
                const existingVar = existing.vars.find(v => v.name === name);
                if (existingVar) {
                    existingVar.value = JSON.stringify(value);
                    existingVar.changed = changed;
                } else {
                    existing.vars.push({ name, value: JSON.stringify(value), type: typeof value, changed });
                }
            } else {
                varHistory.push({ scope, vars: [{ name, value: JSON.stringify(value), type: typeof value, changed }] });
            }
        };
        
        function runVariables() {
            const code = document.getElementById('codeEditor').value;
            varHistory = [];
            varSnapshot = {};
            varStep = 0;
            
            try {
                // Use Babel to track variables
                const transformed = Babel.transform(code, {
                    plugins: [function({ types: t }) {
                        return {
                            visitor: {
                                VariableDeclarator(path) {
                                    const varName = path.node.id.name;
                                    const init = path.node.init;
                                    if (init) {
                                        const trackCall = t.expressionStatement(
                                            t.callExpression(
                                                t.identifier('__trackVar'),
                                                [
                                                    t.stringLiteral('global'),
                                                    t.stringLiteral(varName),
                                                    t.identifier(varName)
                                                ]
                                            )
                                        );
                                        path.getStatementParent().insertAfter(trackCall);
                                    }
                                },
                                FunctionDeclaration(path) {
                                    const funcName = path.node.id?.name || 'anonymous';
                                    path.node.params.forEach(param => {
                                        const paramName = param.name;
                                        const trackCall = t.expressionStatement(
                                            t.callExpression(
                                                t.identifier('__trackVar'),
                                                [
                                                    t.stringLiteral(funcName),
                                                    t.stringLiteral(paramName),
                                                    t.identifier(paramName)
                                                ]
                                            )
                                        );
                                        path.node.body.body.unshift(trackCall);
                                    });
                                }
                            }
                        };
                    }]
                }).code;
                eval(transformed);
                varStep = varHistory.length;
                renderVarTable();
            } catch (e) {
                document.getElementById('varBody').innerHTML = `<tr><td colspan="5" style="color:#f44336;">Error: ${e.message}</td></tr>`;
            }
        }
        
        function stepVariables() {
            if (varStep < varHistory.length) varStep++;
            else varStep = 1;
            renderVarTable();
        }
        
        function renderVarTable() {
            const timeline = document.getElementById('varTimeline');
            timeline.innerHTML = `<div style="display:flex;gap:5px;flex-wrap:wrap;">${varHistory.map((h, i) => 
                `<span style="padding:4px 8px;border-radius:4px;font-size:11px;background:${i < varStep ? '#667eea' : '#3e3e42'};color:${i < varStep ? 'white' : '#858585'};">${h.scope}</span>`
            ).join('')}</div>`;
            
            const body = document.getElementById('varBody');
            let rows = '';
            for (let i = 0; i < varStep; i++) {
                const h = varHistory[i];
                h.vars.forEach(v => {
                    rows += `<tr style="${i === varStep - 1 ? 'background:#2d4a2d;' : ''}">
                        <td style="color:#4ec9b0;">${h.scope}</td>
                        <td style="color:#9cdcfe;">${v.name}</td>
                        <td class="var-value">${v.value}</td>
                        <td style="color:#858585;">${v.type}</td>
                        <td>${v.changed ? '‚úì' : ''}</td>
                    </tr>`;
                });
            }
            body.innerHTML = rows || '<tr><td colspan="5" style="color:#858585;text-align:center;">No variables yet</td></tr>';
        }
        
        updateAllLenses();
    </script>
</body>
</html>
